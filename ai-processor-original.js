// Module IA pour DevisBoostAI
// Utilise Hugging Face Transformers.js pour l'analyse locale

class AIProcessor {
    constructor() {
        this.isInitialized = false;
        this.model = null;
        this.tokenizer = null;
        this.priceDatabase = this.initializePriceDatabase();
    }

    // Base de donn√©es de prix pour le BTP
    initializePriceDatabase() {
        return {
            // √âlectricit√©
            'tableau √©lectrique': { price: 250, unit: 'unit√©', category: '√©lectricit√©' },
            'disjoncteur': { price: 15, unit: 'unit√©', category: '√©lectricit√©' },
            'prise √©lectrique': { price: 12, unit: 'unit√©', category: '√©lectricit√©' },
            'interrupteur': { price: 8, unit: 'unit√©', category: '√©lectricit√©' },
            'point lumineux': { price: 35, unit: 'unit√©', category: '√©lectricit√©' },
            'c√¢ble √©lectrique': { price: 2.5, unit: 'm√®tre', category: '√©lectricit√©' },
            'gaine √©lectrique': { price: 1.2, unit: 'm√®tre', category: '√©lectricit√©' },
            
            // Plomberie
            'radiateur': { price: 180, unit: 'unit√©', category: 'plomberie' },
            'robinet': { price: 45, unit: 'unit√©', category: 'plomberie' },
            'lavabo': { price: 120, unit: 'unit√©', category: 'plomberie' },
            'wc': { price: 150, unit: 'unit√©', category: 'plomberie' },
            'tuyau pvc': { price: 8, unit: 'm√®tre', category: 'plomberie' },
            'tuyau cuivre': { price: 12, unit: 'm√®tre', category: 'plomberie' },
            'chauffe-eau': { price: 450, unit: 'unit√©', category: 'plomberie' },
            
            // Ma√ßonnerie
            'ciment': { price: 8, unit: 'sac', category: 'ma√ßonnerie' },
            'sable': { price: 25, unit: 'm¬≥', category: 'ma√ßonnerie' },
            'gravier': { price: 30, unit: 'm¬≥', category: 'ma√ßonnerie' },
            'brique': { price: 0.8, unit: 'unit√©', category: 'ma√ßonnerie' },
            'parpaing': { price: 1.2, unit: 'unit√©', category: 'ma√ßonnerie' },
            'b√©ton': { price: 90, unit: 'm¬≥', category: 'ma√ßonnerie' },
            
            // Peinture
            'peinture': { price: 25, unit: 'litre', category: 'peinture' },
            'enduit': { price: 18, unit: 'sac', category: 'peinture' },
            'rouleau': { price: 8, unit: 'unit√©', category: 'peinture' },
            'pinceau': { price: 12, unit: 'unit√©', category: 'peinture' },
            
            // Main d'≈ìuvre
            'main d\'≈ìuvre': { price: 45, unit: 'heure', category: 'service' },
            'd√©placement': { price: 35, unit: 'forfait', category: 'service' }
        };
    }

    // Analyse du texte avec IA locale (simulation avanc√©e)
    async analyzeWorkDescription(description) {
        try {
            console.log('üß† Analyse IA en cours...', description);
            
            // Simulation d'analyse IA plus sophistiqu√©e
            const items = this.extractItemsFromDescription(description);
            const estimatedQuantities = this.estimateQuantities(description, items);
            
            return {
                success: true,
                items: estimatedQuantities,
                confidence: 0.85,
                suggestions: this.generateSuggestions(items)
            };
        } catch (error) {
            console.error('Erreur analyse IA:', error);
            return {
                success: false,
                error: error.message,
                items: this.getFallbackItems()
            };
        }
    }

    // Extraction d'√©l√©ments bas√©e sur des mots-cl√©s
    extractItemsFromDescription(description) {
        const text = description.toLowerCase();
        const foundItems = [];
        
        // Recherche de mots-cl√©s dans la description
        for (const [item, data] of Object.entries(this.priceDatabase)) {
            if (text.includes(item) || this.findSynonyms(text, item)) {
                foundItems.push({
                    name: item,
                    ...data
                });
            }
        }
        
        // Si aucun √©l√©ment trouv√©, utiliser des √©l√©ments par d√©faut selon le contexte
        if (foundItems.length === 0) {
            return this.getDefaultItemsByContext(text);
        }
        
        return foundItems;
    }

    // Recherche de synonymes et variantes
    findSynonyms(text, item) {
        const synonyms = {
            'tableau √©lectrique': ['tableau', 'coffret √©lectrique', 'armoire √©lectrique'],
            'prise √©lectrique': ['prise', 'sortie √©lectrique'],
            'interrupteur': ['inter', 'commutateur'],
            'point lumineux': ['√©clairage', 'luminaire', 'lampe'],
            'radiateur': ['chauffage', 'convecteur'],
            'robinet': ['mitigeur', 'm√©langeur'],
            'wc': ['toilettes', 'sanitaire'],
            'main d\'≈ìuvre': ['travail', 'installation', 'pose', 'montage']
        };
        
        if (synonyms[item]) {
            return synonyms[item].some(synonym => text.includes(synonym));
        }
        return false;
    }

    // Estimation des quantit√©s bas√©e sur le contexte
    estimateQuantities(description, items) {
        const text = description.toLowerCase();
        const estimatedItems = [];
        
        // Extraction de la surface si mentionn√©e
        const surfaceMatch = text.match(/(\d+)\s*m[¬≤2]/);
        const surface = surfaceMatch ? parseInt(surfaceMatch[1]) : 50; // D√©faut 50m¬≤
        
        // Extraction du nombre de pi√®ces
        const roomsMatch = text.match(/(\d+)\s*pi√®ces?/);
        const rooms = roomsMatch ? parseInt(roomsMatch[1]) : 3; // D√©faut 3 pi√®ces
        
        items.forEach(item => {
            let quantity = 1;
            
            // Estimation intelligente des quantit√©s
            switch (item.name) {
                case 'prise √©lectrique':
                    quantity = Math.max(8, Math.floor(surface / 10) + rooms * 2);
                    break;
                case 'interrupteur':
                    quantity = Math.max(5, rooms * 2);
                    break;
                case 'point lumineux':
                    quantity = Math.max(4, rooms + 2);
                    break;
                case 'c√¢ble √©lectrique':
                    quantity = Math.max(50, surface * 2);
                    break;
                case 'peinture':
                    quantity = Math.max(5, Math.ceil(surface * 0.3)); // 0.3L/m¬≤
                    break;
                case 'main d\'≈ìuvre':
                    quantity = Math.max(8, Math.floor(surface / 5)); // 1h pour 5m¬≤
                    break;
                default:
                    // Recherche de quantit√©s explicites dans le texte
                    const explicitQuantity = this.extractExplicitQuantity(text, item.name);
                    quantity = explicitQuantity || this.getDefaultQuantity(item.category);
            }
            
            estimatedItems.push({
                description: this.formatItemDescription(item.name),
                quantity: quantity,
                unitPrice: item.price,
                total: quantity * item.price,
                unit: item.unit,
                category: item.category
            });
        });
        
        // Ajouter automatiquement la main d'≈ìuvre si pas pr√©sente
        if (!estimatedItems.some(item => item.category === 'service')) {
            const laborHours = Math.max(8, Math.floor(surface / 8));
            estimatedItems.push({
                description: 'Main d\'≈ìuvre qualifi√©e',
                quantity: laborHours,
                unitPrice: 45,
                total: laborHours * 45,
                unit: 'heure',
                category: 'service'
            });
        }
        
        return estimatedItems;
    }

    // Extraction de quantit√©s explicites du texte
    extractExplicitQuantity(text, itemName) {
        const patterns = [
            new RegExp(`(\\d+)\\s*${itemName}`, 'i'),
            new RegExp(`${itemName}\\s*(\\d+)`, 'i'),
            new RegExp(`(\\d+)\\s*x\\s*${itemName}`, 'i')
        ];
        
        for (const pattern of patterns) {
            const match = text.match(pattern);
            if (match) {
                return parseInt(match[1]);
            }
        }
        return null;
    }

    // Quantit√©s par d√©faut selon la cat√©gorie
    getDefaultQuantity(category) {
        const defaults = {
            '√©lectricit√©': 5,
            'plomberie': 3,
            'ma√ßonnerie': 10,
            'peinture': 2,
            'service': 8
        };
        return defaults[category] || 1;
    }

    // Formatage des descriptions d'√©l√©ments
    formatItemDescription(itemName) {
        const formatted = {
            'tableau √©lectrique': 'Tableau √©lectrique 4 rang√©es',
            'disjoncteur': 'Disjoncteur 20A',
            'prise √©lectrique': 'Prise √©lectrique standard',
            'interrupteur': 'Interrupteur simple',
            'point lumineux': 'Point lumineux avec douille',
            'c√¢ble √©lectrique': 'C√¢ble √©lectrique 2.5mm¬≤',
            'main d\'≈ìuvre': 'Main d\'≈ìuvre qualifi√©e'
        };
        
        return formatted[itemName] || itemName.charAt(0).toUpperCase() + itemName.slice(1);
    }

    // √âl√©ments par d√©faut selon le contexte
    getDefaultItemsByContext(text) {
        if (text.includes('√©lectri') || text.includes('√©lectr')) {
            return [
                { name: 'tableau √©lectrique', price: 250, unit: 'unit√©', category: '√©lectricit√©' },
                { name: 'disjoncteur', price: 15, unit: 'unit√©', category: '√©lectricit√©' },
                { name: 'prise √©lectrique', price: 12, unit: 'unit√©', category: '√©lectricit√©' },
                { name: 'c√¢ble √©lectrique', price: 2.5, unit: 'm√®tre', category: '√©lectricit√©' }
            ];
        } else if (text.includes('plomb') || text.includes('eau') || text.includes('chauff')) {
            return [
                { name: 'radiateur', price: 180, unit: 'unit√©', category: 'plomberie' },
                { name: 'tuyau pvc', price: 8, unit: 'm√®tre', category: 'plomberie' },
                { name: 'robinet', price: 45, unit: 'unit√©', category: 'plomberie' }
            ];
        } else if (text.includes('peintu') || text.includes('enduit')) {
            return [
                { name: 'peinture', price: 25, unit: 'litre', category: 'peinture' },
                { name: 'enduit', price: 18, unit: 'sac', category: 'peinture' }
            ];
        }
        
        // D√©faut g√©n√©rique
        return [
            { name: 'mat√©riaux divers', price: 50, unit: 'forfait', category: 'g√©n√©ral' },
            { name: 'main d\'≈ìuvre', price: 45, unit: 'heure', category: 'service' }
        ];
    }

    // √âl√©ments de secours en cas d'erreur
    getFallbackItems() {
        return [
            {
                description: 'Mat√©riaux et fournitures',
                quantity: 1,
                unitPrice: 200,
                total: 200,
                unit: 'forfait',
                category: 'g√©n√©ral'
            },
            {
                description: 'Main d\'≈ìuvre qualifi√©e',
                quantity: 8,
                unitPrice: 45,
                total: 360,
                unit: 'heure',
                category: 'service'
            }
        ];
    }

    // G√©n√©ration de suggestions
    generateSuggestions(items) {
        const suggestions = [];
        
        if (items.some(item => item.category === '√©lectricit√©')) {
            suggestions.push('üí° Pensez √† inclure la mise aux normes √©lectriques');
            suggestions.push('‚ö° V√©rifiez si un certificat Consuel est n√©cessaire');
        }
        
        if (items.some(item => item.category === 'plomberie')) {
            suggestions.push('üîß N\'oubliez pas l\'√©tanch√©it√© et les raccordements');
            suggestions.push('üíß Pr√©voyez une marge pour les impr√©vus de plomberie');
        }
        
        suggestions.push('üìã Ajoutez 10% de marge pour les impr√©vus');
        suggestions.push('üöõ Pensez aux frais de transport et √©vacuation');
        
        return suggestions;
    }

    // Am√©lioration des prix bas√©e sur la localisation (simulation)
    adjustPricesForLocation(items, location = 'France') {
        const locationMultipliers = {
            'Paris': 1.3,
            'Lyon': 1.15,
            'Marseille': 1.1,
            'France': 1.0
        };
        
        const multiplier = locationMultipliers[location] || 1.0;
        
        return items.map(item => ({
            ...item,
            unitPrice: Math.round(item.unitPrice * multiplier * 100) / 100,
            total: Math.round(item.quantity * item.unitPrice * multiplier * 100) / 100
        }));
    }
}

// Export pour utilisation
window.AIProcessor = AIProcessor;

